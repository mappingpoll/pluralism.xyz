import { BaseType, path, Path, Selection } from "d3";
import * as THREE from "three";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader";

import { xScale, yScale } from "../../lib/scales";
import { ORIGIN, DOMAIN, ARROW_PADDING, ARROW_LENGTH, ARROW_FEATHER_SIZE, VIEWBOX } from "../../lib/constants";
import { questions } from "../../lib/questions";
import { color } from "../../lib/style";

const CARDINALS = [
  [
    [
      [1, 0],
      [0, 1],
    ],
    [
      [-1, 0],
      [0, 1],
    ],
  ],
  [
    [
      [0, -1],
      [1, 0],
    ],
    [
      [0, -1],
      [-1, 0],
    ],
  ],
  [
    [
      [-1, 0],
      [0, -1],
    ],
    [
      [1, 0],
      [0, -1],
    ],
  ],
  [
    [
      [0, 1],
      [-1, 0],
    ],
    [
      [0, 1],
      [1, 0],
    ],
  ],
];

const ARROW_TIPS = [
  [ORIGIN.x, 0],
  [VIEWBOX[2], ORIGIN.y],
  [ORIGIN.x, VIEWBOX[3]],
  [0, ORIGIN.y],
];

const arrowPaths = ARROW_TIPS.map((arrow, i) => {
  const translate = (n: 0 | 1) => (p: number, j: number) =>
    p + CARDINALS[i][n][j][0] * ARROW_FEATHER_SIZE + CARDINALS[i][n][j][1] * ARROW_LENGTH;
  const v1 = arrow.map(translate(0));
  const v2 = arrow.map(translate(1));
  return [...arrow, ...v1, ...v2];
});

function drawXaxis(path: Path) {
  path.moveTo(xScale(DOMAIN[0]) - ARROW_PADDING, ORIGIN.y);
  path.lineTo(xScale(DOMAIN[1]) + ARROW_PADDING, ORIGIN.y);
  return path.toString();
}
function drawYaxis(path: Path) {
  path.moveTo(ORIGIN.x, yScale(DOMAIN[0]) + ARROW_PADDING);
  path.lineTo(ORIGIN.x, yScale(DOMAIN[1]) - ARROW_PADDING);
  return path.toString();
}

export function xAxis<E extends BaseType, D, P extends BaseType, PD>(g: Selection<E, D, P, PD>) {
  return g.append("path").attr("class", "axis").attr("d", drawXaxis(path()));
}
export function yAxis<E extends BaseType, D, P extends BaseType, PD>(g: Selection<E, D, P, PD>) {
  return g.append("path").attr("class", "axis").attr("d", drawYaxis(path()));
}

export function arrowheads<E extends BaseType, D, P extends BaseType, PD>(g: Selection<E, D, P, PD>) {
  g.attr("class", "arrowhead")
    .selectAll("path")
    .data(arrowPaths)
    .join("path")
    .attr("d", d => `M${d[0]} ${d[1]} L ${d[2]} ${d[3]} L ${d[4]} ${d[5]} Z`);
}

export function appendAxes<Parent extends BaseType>(svg: Selection<SVGElement, unknown, Parent, unknown>) {
  svg.append("g").call(xAxis);
  svg.append("g").call(yAxis);
  svg.append("g").call(arrowheads);
}

// 3D
const axisMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

const xAxisGeo = new THREE.BufferGeometry().setFromPoints([
  new THREE.Vector3(-1.2, 0, 0),
  new THREE.Vector3(1.2, 0, 0),
  new THREE.Vector3(1.2, 0, 0.05),
]);

const yAxisGeo = new THREE.BufferGeometry().setFromPoints([
  new THREE.Vector3(0, -1.2, 0),
  new THREE.Vector3(0, 1.2, 0),
  new THREE.Vector3(0, 1.2, 0.05),
]);

const zAxisGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]);

const x = new THREE.Line(xAxisGeo, axisMaterial);
const y = new THREE.Line(yAxisGeo, axisMaterial);
const z = new THREE.Line(zAxisGeo, axisMaterial);

const axes = new THREE.Object3D();
axes.add(x, y, z);

const textMaterial = new THREE.MeshBasicMaterial({ color: color.fg, side: THREE.DoubleSide });
const fontLoader = new FontLoader();

const LABEL_OFFSET = 1.3;
const PI = Math.PI;

export function makeAxesPlane(x: string, y: string) {
  const xMax = questions[x].max;
  const xMin = questions[x].min;
  const yMax = questions[y].max;
  const yMin = questions[y].min;

  const g = new THREE.Object3D();

  interface Label {
    position: [number, number, number];
    rotateZ: number;
    relative: [[string, number], [string, number]];
    text: string;
  }

  const labels: { [key: string]: Label } = {
    xMin: {
      position: [-LABEL_OFFSET, 0, 0],
      rotateZ: (3 * PI) / 2,
      relative: [
        ["x", 1],
        ["y", 1],
      ],
      text: xMin,
    },
    xMax: {
      position: [LABEL_OFFSET, 0, 0],
      rotateZ: PI / 2,
      relative: [
        ["x", 1],
        ["y", 1],
      ],
      text: xMax,
    },
    yMin: {
      position: [0, -LABEL_OFFSET, 0],
      rotateZ: 0,
      relative: [
        ["x", 1],
        ["y", 1],
      ],
      text: yMin,
    },
    yMax: {
      position: [0, LABEL_OFFSET, 0],
      rotateZ: PI,
      relative: [
        ["x", 1],
        ["y", 1],
      ],
      text: yMax,
    },
  };

  Object.values(labels).forEach(label => {
    fontLoader.load("/assets/results2021/Open Sans Light_Regular.json", function (font) {
      const shapes = font.generateShapes(label.text, 0.05);

      const geometry = new THREE.ShapeGeometry(shapes);

      geometry.rotateZ(label.rotateZ);
      geometry.translate(...label.position);

      geometry.computeBoundingBox();

      const mid = {
        x: (geometry.boundingBox.max.x - geometry.boundingBox.min.x) / 2,
        y: (geometry.boundingBox.max.y - geometry.boundingBox.min.y) / 2,
      };

      // geometry.translate(mid.x, mid.y, 0);

      const text = new THREE.Mesh(geometry, textMaterial);
      g.add(text);
    });
  });

  g.add(axes.clone());

  return g;
}
